package main

import (
	"context"
	"errors"
	"log"
	"net/http"
	"os"

	"connectrpc.com/connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	calculatorv1 "ConnectRPC-Demo/gen/calculator/v1"        // generated by protoc-gen-go
	"ConnectRPC-Demo/gen/calculator/v1/calculatorv1connect" // generated by protoc-gen-connect-go
)

type calculatorServer struct{}

// Add 实现加法逻辑
func (s *calculatorServer) Add(
	ctx context.Context,
	req *connect.Request[calculatorv1.OperateRequest],
) (*connect.Response[calculatorv1.OperateResponse], error) {
	log.Println("请求头:", req.Header())
	result := req.Msg.Number1 + req.Msg.Number2
	res := connect.NewResponse(&calculatorv1.OperateResponse{
		Result: result,
	})
	// 可选：设置响应头
	// res.Header().Set("Calculator-Version", "v1")
	return res, nil
}

// Subtract 实现减法逻辑
func (s *calculatorServer) Subtract(
	ctx context.Context,
	req *connect.Request[calculatorv1.OperateRequest],
) (*connect.Response[calculatorv1.OperateResponse], error) {
	result := req.Msg.Number1 - req.Msg.Number2
	res := connect.NewResponse(&calculatorv1.OperateResponse{
		Result: result,
	})
	return res, nil
}

// Multiply 实现乘法逻辑
func (s *calculatorServer) Multiply(
	ctx context.Context,
	req *connect.Request[calculatorv1.OperateRequest],
) (*connect.Response[calculatorv1.OperateResponse], error) {
	result := req.Msg.Number1 * req.Msg.Number2
	res := connect.NewResponse(&calculatorv1.OperateResponse{
		Result: result,
	})
	return res, nil
}

// Divide 实现除法逻辑
func (s *calculatorServer) Divide(
	ctx context.Context,
	req *connect.Request[calculatorv1.OperateRequest],
) (*connect.Response[calculatorv1.OperateResponse], error) {
	if req.Msg.Number2 == 0 {
		// 使用 Connect 错误码
		return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("除数不能为零"))
	}
	result := req.Msg.Number1 / req.Msg.Number2
	res := connect.NewResponse(&calculatorv1.OperateResponse{
		Result: result,
	})
	return res, nil
}

// CORS 中间件
func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
		// 替代方案：允许所有请求头
		w.Header().Set("Access-Control-Allow-Headers", "*")

		// 处理预检请求
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func main() {
	// 创建服务实现
	calculator := &calculatorServer{}

	// 创建 HTTP Mux
	mux := http.NewServeMux()

	// 创建 Connect 处理器并包裹 CORS 中间件
	path, handler := calculatorv1connect.NewCalculatorServiceHandler(calculator)
	corsHandler := corsMiddleware(handler)
	mux.Handle(path, corsHandler)

	// 定义服务器地址和端口
	addr := ":8080"
	if port := os.Getenv("PORT"); port != "" {
		addr = ":" + port
	}
	log.Printf("服务正在监听 %s\n", addr)

	// 启动服务器
	// 使用 h2c 创建支持 HTTP/2 明文的服务器 (适用于本地开发和不需要 TLS 的场景)
	// 对于生产环境，你应该使用 TLS
	err := http.ListenAndServe(
		addr,
		h2c.NewHandler(mux, &http2.Server{}), // 使用 h2c 和 CORS
	)
	if err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatalf("启动服务器失败: %v", err)
	}
}
